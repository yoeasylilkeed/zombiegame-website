<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Nightfall: Zombie Streets — HTML5 Shooter (Copyable)</title>
<style>
  html,body{height:100%;margin:0;background:#0e0f13;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:#e6eef8}
  #wrap{display:flex;align-items:center;justify-content:center;height:100%;padding:20px;box-sizing:border-box}
  canvas{background:linear-gradient(#101217,#0b0c10);border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,0.6)}
  .panel{position:fixed;right:24px;top:24px;width:260px;background:rgba(255,255,255,0.03);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.04)}
  .panel h3{margin:0 0 6px 0;font-size:16px}
  .btn{appearance:none;border:0;padding:8px 10px;border-radius:8px;background:#2b8a3e;color:white;cursor:pointer;font-weight:700}
  .small{font-size:12px;color:#bcd0ea}
  .footer{position:fixed;left:20px;bottom:12px;color:#9fb2d9;font-size:13px}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="1024" height="640"></canvas>
</div>
<div class="panel">
  <h3>Nightfall: Zombie Streets</h3>
  <div class="small">W/A/S/D to move • Mouse aim • Left-click to shoot • R restart • 1 = pistol • 2 = shotgun</div>
  <hr style="opacity:.06;border:0;border-top:1px solid rgba(255,255,255,0.04);margin:8px 0">
  <div>Score: <span id="uiScore">0</span></div>
  <div>Wave: <span id="uiWave">1</span></div>
  <div>HP: <span id="uiHP">100</span></div>
  <div>Ammo: <span id="uiAmmo">—</span></div>
  <div style="margin-top:8px"><button class="btn" id="restartBtn">Restart</button></div>
  <div style="margin-top:8px" class="small">This is a single-file, copyable HTML5 game. Open in a browser — no build needed.</div>
</div>
<div class="footer">Tip: Survive waves — each wave increases zombies and difficulty.</div>

<script>
// Nightfall: Zombie Streets — single-file HTML5 shooter
// Non-graphic violence only. Feel free to copy, edit, and reuse.

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

// UI elements
const uiScore = document.getElementById('uiScore');
const uiWave = document.getElementById('uiWave');
const uiHP = document.getElementById('uiHP');
const uiAmmo = document.getElementById('uiAmmo');
const restartBtn = document.getElementById('restartBtn');

// Game state
let keys = {}; let mouse = {x:0,y:0,down:false};
let score = 0; let highscore = Number(localStorage.getItem('nf_high')||0);
let wave = 1; let enemies = []; let bullets = []; let pickups = [];
let gameOver = false; let paused = false;

// Player
const player = {
  x: W/2, y: H/2, r: 14, speed: 2.6, hp: 100, maxHp: 100,
  weapon: 'pistol', // 'pistol' | 'shotgun'
  pistolAmmo: 999, // infinite for pistol
  shotgunAmmo: 20,
  fireCooldown: 0
};

// Settings
const SPAWN_PADDING = 80;
const ENEMY_BASE_SPEED = 0.6;
const ENEMY_HEALTH = 28;

// Utility
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
function rand(min,max){ return Math.random()*(max-min)+min; }

// Input
window.addEventListener('keydown', e=>{ keys[e.key.toLowerCase()] = true; if(e.key==='r' || e.key==='R') restart(); if(e.key==='1') selectWeapon('pistol'); if(e.key==='2') selectWeapon('shotgun'); });
window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()] = false; });
canvas.addEventListener('mousemove', e=>{ const rect = canvas.getBoundingClientRect(); mouse.x = e.clientX - rect.left; mouse.y = e.clientY - rect.top; });
canvas.addEventListener('mousedown', e=>{ if(e.button===0) mouse.down = true; });
canvas.addEventListener('mouseup', e=>{ if(e.button===0) mouse.down = false; });

restartBtn.addEventListener('click', ()=> restart());

function selectWeapon(w){ player.weapon = w; updateUI(); }

// Enemy factory
function spawnEnemy(type, x, y){
  // types: walker, runner, armored
  const e = { id: Math.random().toString(36).slice(2,9), x, y, type, vx:0, vy:0, dead:false };
  if(type==='walker'){ e.speed = ENEMY_BASE_SPEED + rand(0,0.2); e.hp = ENEMY_HEALTH; e.color = '#9bbf6b'; }
  else if(type==='runner'){ e.speed = ENEMY_BASE_SPEED*2 + rand(0,0.6); e.hp = ENEMY_HEALTH*0.7; e.color = '#d9b56a'; }
  else if(type==='armored'){ e.speed = ENEMY_BASE_SPEED*0.6; e.hp = ENEMY_HEALTH*3; e.color = '#9aa9b0'; }
  enemies.push(e);
}

function spawnWave(n){
  for(let i=0;i<n;i++){
    // spawn around edges
    const side = Math.floor(rand(0,4));
    let x,y;
    if(side===0){ x = rand(-SPAWN_PADDING, 0); y = rand(0, H); }
    if(side===1){ x = rand(W, W+SPAWN_PADDING); y = rand(0, H); }
    if(side===2){ x = rand(0, W); y = rand(-SPAWN_PADDING, 0); }
    if(side===3){ x = rand(0, W); y = rand(H, H+SPAWN_PADDING); }
    // type chance
    const r = Math.random();
    if(r < 0.7) spawnEnemy('walker', x, y);
    else if(r < 0.9) spawnEnemy('runner', x, y);
    else spawnEnemy('armored', x, y);
  }
}

// Bullets
function fireBullet(x,y,dx,dy,opts={}){
  bullets.push({x,y,dx,dy,life:opts.life||60, speed: opts.speed||8, dmg: opts.dmg||12, radius: opts.radius||4, owner:'player'});
}

// Pickups
function spawnPickup(type,x,y){ pickups.push({type,x,y,ttl:600}); }

// Game logic
function update(){
  if(gameOver || paused) return;

  // player movement
  let mx=0,my=0; if(keys['w']) my-=1; if(keys['s']) my+=1; if(keys['a']) mx-=1; if(keys['d']) mx+=1;
  const mlen = Math.hypot(mx,my) || 1; player.x += (mx/mlen) * player.speed; player.y += (my/mlen) * player.speed;
  player.x = clamp(player.x, 10, W-10); player.y = clamp(player.y, 10, H-10);

  // shooting
  player.fireCooldown = Math.max(0, player.fireCooldown - 1);
  if(mouse.down && player.fireCooldown === 0){
    const ang = Math.atan2(mouse.y - player.y, mouse.x - player.x);
    if(player.weapon === 'pistol'){
      fireBullet(player.x + Math.cos(ang)*20, player.y + Math.sin(ang)*20, Math.cos(ang), Math.sin(ang), {speed:12, dmg:24, life:60});
      player.fireCooldown = 10;
    } else if(player.weapon === 'shotgun'){
      if(player.shotgunAmmo > 0){
        const pellets = 7; const spread = 0.6;
        for(let i=0;i<pellets;i++){ const a = ang + rand(-spread, spread); fireBullet(player.x + Math.cos(a)*18, player.y + Math.sin(a)*18, Math.cos(a), Math.sin(a), {speed:10, dmg:10, life:30}); }
        player.shotgunAmmo--; player.fireCooldown = 22;
        if(player.shotgunAmmo < 0) player.shotgunAmmo = 0;
      }
    }
    updateUI();
  }

  // update bullets
  for(let i = bullets.length-1; i>=0; i--){ const b = bullets[i]; b.x += b.dx * b.speed; b.y += b.dy * b.speed; b.life--; if(b.life<=0) bullets.splice(i,1); }

  // enemies AI: simple seek & collision
  for(let i = enemies.length-1; i>=0; i--){ const e = enemies[i]; if(e.dead) continue;
    const dx = player.x - e.x; const dy = player.y - e.y; const d = Math.hypot(dx,dy) || 1;
    e.vx = (dx/d) * e.speed; e.vy = (dy/d) * e.speed;
    e.x += e.vx; e.y += e.vy;

    // damage to player when very close
    if(d < 18){ // enemy attack
      player.hp -= 0.25 * (e.type==='armored'?2:1);
      if(player.hp <= 0){ player.hp = 0; die(); }
      updateUI();
    }

    // check bullet hits
    for(let j = bullets.length-1; j>=0; j--){ const b = bullets[j]; const dx2 = b.x - e.x; const dy2 = b.y - e.y; if(Math.hypot(dx2,dy2) < (b.radius + 12)){
        // hit
        e.hp -= b.dmg || 12;
        // cheap knockback
        e.x += b.dx * 6; e.y += b.dy * 6;
        bullets.splice(j,1);
        if(e.hp <= 0){ e.dead = true; score += (e.type==='armored'?60:(e.type==='runner'?20:10));
            // small chance for pickup
            if(Math.random() < 0.12) spawnPickup(Math.random()<0.6?'health':'ammo', e.x, e.y);
            // remove after death animation frames - here immediate removal and particles
            spawnDeathParticles(e.x, e.y, e.color);
        }
        break;
    }}

    // remove dead
    if(e.dead){ enemies.splice(i,1); }
  }

  // pickups
  for(let i = pickups.length-1; i>=0; i--){ const p = pickups[i]; p.ttl--; if(p.ttl<=0) pickups.splice(i,1); else if(Math.hypot(player.x-p.x, player.y-p.y) < 18){
      if(p.type==='health'){ player.hp = Math.min(player.maxHp, player.hp + 25); }
      else if(p.type==='ammo'){ player.shotgunAmmo = Math.min(99, player.shotgunAmmo + 6); }
      pickups.splice(i,1); updateUI(); }
  }

  // spawn next wave if no enemies left
  if(enemies.length === 0){ wave++; uiWave.textContent = wave; const count = 4 + Math.floor(wave * 1.8); spawnWave(count); // tiny break between waves
    // award small heal
    player.hp = Math.min(player.maxHp, player.hp + 8);
    updateUI();
  }
}

// simple particle system for enemy death (visual only)
let particles = [];
function spawnDeathParticles(x,y, color){ for(let i=0;i<12;i++){ particles.push({x,y,vx:rand(-2,2),vy:rand(-2,2),life:40, color}); } }

function updateParticles(){ for(let i=particles.length-1;i>=0;i--){ const p = particles[i]; p.x += p.vx; p.y += p.vy; p.life--; if(p.life<=0) particles.splice(i,1); }}

// draw
function draw(){
  // background gradient + vignette
  const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#0b0c10'); g.addColorStop(1,'#0e1116'); ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

  // city grid — subtle
  ctx.save(); ctx.globalAlpha = 0.04; ctx.strokeStyle='#fff'; for(let x=0;x<W;x+=48){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); } for(let y=0;y<H;y+=48){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); } ctx.restore();

  // draw pickups
  for(const p of pickups){ ctx.fillStyle = p.type==='health'?'#7ee1a0':'#f4d06f'; ctx.beginPath(); ctx.arc(p.x,p.y,8,0,Math.PI*2); ctx.fill(); ctx.strokeStyle='rgba(0,0,0,0.2)'; ctx.stroke(); }

  // draw enemies
  for(const e of enemies){ ctx.save(); ctx.translate(e.x,e.y); // body
    ctx.beginPath(); ctx.fillStyle=e.color; ctx.rect(-12,-12,24,24); ctx.fill(); // eyes
    ctx.fillStyle='#08121a'; ctx.fillRect(-6,-6,5,5); ctx.fillRect(2,-6,5,5);
    ctx.restore(); }

  // draw bullets
  for(const b of bullets){ ctx.beginPath(); ctx.fillStyle='#ffd96b'; ctx.arc(b.x,b.y,b.radius,0,Math.PI*2); ctx.fill(); }

  // draw particles
  for(const p of particles){ ctx.globalAlpha = clamp(p.life/40,0,1); ctx.fillStyle = p.color; ctx.fillRect(p.x-2,p.y-2,4,4); ctx.globalAlpha = 1; }

  // draw player (circle + weapon)
  ctx.save(); ctx.translate(player.x, player.y);
  // shadow
  ctx.beginPath(); ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.ellipse(0,12,18,8,0,0,Math.PI*2); ctx.fill();
  // body
  ctx.beginPath(); ctx.fillStyle='#ffd9b5'; ctx.arc(0,0,player.r,0,Math.PI*2); ctx.fill();
  // weapon aiming
  const ang = Math.atan2(mouse.y - player.y, mouse.x - player.x);
  ctx.rotate(ang);
  // gun body
  ctx.fillStyle = '#2b2d42'; ctx.fillRect(10, -6, 26, 12);
  // muzzle flash placeholder when firing
  if(player.fireCooldown > 0 && mouse.down){ ctx.fillStyle = '#ffd96b'; ctx.fillRect(36, -4, 8, 8); }
  ctx.restore();

  // HUD crosshair
  ctx.beginPath(); ctx.strokeStyle='rgba(255,255,255,0.7)'; ctx.lineWidth=1; ctx.moveTo(mouse.x-10,mouse.y); ctx.lineTo(mouse.x+10,mouse.y); ctx.moveTo(mouse.x,mouse.y-10); ctx.lineTo(mouse.x,mouse.y+10); ctx.stroke();

  // overlay text
  ctx.fillStyle='rgba(255,255,255,0.06)'; ctx.fillRect(0,0, W, 46);
  ctx.fillStyle='#e6eef8'; ctx.font='18px system-ui'; ctx.fillText('Nightfall — Zombie Streets', 18, 28);
  ctx.fillStyle='#9fb2d9'; ctx.font='14px system-ui'; ctx.fillText('Highscore: '+highscore, 820, 28);

  if(gameOver){ ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(0,0,W,H); ctx.fillStyle='#fff'; ctx.font='36px system-ui'; ctx.fillText('Game Over', W/2-110, H/2 - 6); ctx.font='18px system-ui'; ctx.fillText('Press Restart to play again', W/2-120, H/2 + 24); }
}

function updateUI(){ uiScore.textContent = score; uiWave.textContent = wave; uiHP.textContent = Math.floor(player.hp); uiAmmo.textContent = player.weapon==='pistol' ? '∞' : player.shotgunAmmo; }

function die(){ gameOver = true; if(score > highscore){ highscore = score; localStorage.setItem('nf_high', highscore); } }

// spawn some initial enemies and pickups
function init(){ enemies = []; bullets = []; pickups = []; particles = []; score = 0; wave = 0; player.x = W/2; player.y = H/2; player.hp = player.maxHp; player.shotgunAmmo = 16; player.fireCooldown = 0; player.weapon = 'pistol'; gameOver = false; spawnWave(4); updateUI(); }

// simple visual wave spawn schedule (gives a small pause between waves)
let spawnPause = 0;

// main loop
function loop(){ update(); updateParticles(); draw(); if(!gameOver) requestAnimationFrame(loop); }

// fire rate handler: reduce ammo and manage cooldown handled in update
// collisions already dealt

// spawn death particles already in hit logic

// spawn wave exposed earlier

// start
init(); loop();

// utilities used earlier but defined lower due to grouping
function spawnWave(n){ // small scheduled spawns rather than all at once
  for(let i=0;i<n;i++){
    setTimeout(()=>{ const side = Math.floor(rand(0,4)); let x,y; if(side===0){ x = rand(-SPAWN_PADDING, 0); y = rand(0, H); } if(side===1){ x = rand(W, W+SPAWN_PADDING); y = rand(0, H); } if(side===2){ x = rand(0, W); y = rand(-SPAWN_PADDING, 0); } if(side===3){ x = rand(0, W); y = rand(H, H+SPAWN_PADDING); } const r = Math.random(); if(r < 0.7) spawnEnemy('walker', x, y); else if(r < 0.9) spawnEnemy('runner', x, y); else spawnEnemy('armored', x, y); }, i*250);
  }
}

function spawnEnemy(type, x, y){
  const e = { id: Math.random().toString(36).slice(2,9), x, y, type, vx:0, vy:0, dead:false };
  if(type==='walker'){ e.speed = ENEMY_BASE_SPEED + rand(0,0.24); e.hp = ENEMY_HEALTH; e.color = '#7fb86a'; }
  else if(type==='runner'){ e.speed = ENEMY_BASE_SPEED*2 + rand(0,0.6); e.hp = Math.floor(ENEMY_HEALTH*0.7); e.color = '#d99f6a'; }
  else if(type==='armored'){ e.speed = ENEMY_BASE_SPEED*0.6; e.hp = ENEMY_HEALTH*3; e.color = '#9aa9b0'; }
  enemies.push(e);
}

function restart(){ init(); if(gameOver) { gameOver=false; loop(); } }

// small loop to ensure game continues after waves
setInterval(()=>{
  if(gameOver) return;
  // if no enemies, spawn next wave after a short pause
  if(enemies.length === 0 && spawnPause===0){ spawnPause = 1; setTimeout(()=>{ const count = 3 + Math.floor(wave * 2.2); spawnWave(count); spawnPause = 0; }, 750); }
  // incremental score increase for survival
  score += 0.02; score = Math.floor(score*100)/100;
  updateUI();
}, 200);

</script>
</body>
</html>